
/**
 * Core Philosophy: This ruleset implements a role-based security model for the HG Hub application,
 * clearly distinguishing between 'Admins' and 'Clients'. Admins, identified by the existence of a document
 * in the /roles_admin collection, have broad permissions to manage platform data. Clients are restricted
 * to viewing and interacting with only the projects and associated data they have been assigned to.
 *
 * Data Structure: The data is structured around a central `/projects` collection. Each project document
 * contains a denormalized `clientId` field, which is the primary mechanism for granting access to clients.
 * All project-specific data (timeline, invoices, messages) are stored in subcollections under their
 * respective project document. Administrative roles are managed separately in a top-level `/roles_admin`
 * collection for clean segregation of concerns.
 *
 * Key Security Decisions:
 * - Admin Role Management: A user is considered an admin if a document with their UID exists in the
 *   `/roles_admin` collection. This collection is read-only via security rules to prevent modification
 *   from the client, ensuring roles are managed securely through a trusted backend process.
 * - Client Data Segregation: Client access is strictly controlled via a `clientId` field denormalized
 *   onto each project document. This avoids costly and insecure `get` calls in list queries and ensures
 *   a client can never access another client's project data.
 * - Write Access Restriction: All write operations (create, update, delete) are restricted to Admins,
 *   with the exception of clients being able to create messages within their assigned projects.
 * - Disallowing Open Listing: Listing documents in top-level collections like `/projects` and `/clients`
 *   is restricted to Admins to prevent data leakage. Clients must query for their specific projects.
 *
 * Denormalization for Authorization: To enforce client-specific access on project subcollections
 * (e.g., invoices, messages), rules perform a `get()` call to the parent `/projects/{projectId}` document.
 * This checks the denormalized `clientId` field on the project, granting access if the requesting user's
 * UID matches. This is far more performant and secure than attempting to join data across collections.
 *
 * Structural Segregation: Administrative data (`/roles_admin`) is stored in a separate collection from
 * core application data (`/clients`, `/projects`). This separation allows for fundamentally different and
*  much stricter security rules on the role-defining documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for concise and readable rules
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks if the signed-in user has an admin role document.
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // Checks if the user is the client associated with a given project.
    // Requires a get() on the parent project document which contains the denormalized clientId.
    function isClientOfProject(projectId) {
      let projectData = get(/databases/$(database)/documents/projects/$(projectId)).data;
      return isOwner(projectData.clientId);
    }

    // Grants access if user is an admin or the designated client for the project.
    function canAccessProjectData(projectId) {
      return isAdmin() || isClientOfProject(projectId);
    }
    
    /**
     * @description Publicly writable collection for contact form submissions.
     * @path /inquiries/{inquiryId}
     * @allow (create) Anyone can submit an inquiry.
     * @deny (read, update, delete) No one can read or modify inquiries from the client-side.
     * @principle Captures leads securely without requiring authentication.
     */
    match /inquiries/{inquiryId} {
      allow create: if request.resource.data.name is string &&
                       request.resource.data.email is string &&
                       request.resource.data.idea is string &&
                       request.resource.data.createdAt == request.time;
      allow read, update, delete: if false;
    }

    /**
     * @description Defines admin roles. Existence of a document grants admin privileges.
     * This collection should only be managed by a trusted server process, not clients.
     * @path /roles_admin/{userId}
     * @allow (get) An admin reading another admin's role document.
     * @deny (list, create, update, delete) Any user attempting to modify roles from the client.
     * @principle Segregates administrative data and makes it read-only to prevent tampering.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores information about Hajaro Grahako team members.
     * This data is sensitive and should only be managed by administrators.
     * @path /team_members/{teamMemberId}
     * @allow (get, list, create, update, delete) An admin managing team member profiles.
     * @deny (get, list, write) Any non-admin user attempting to access or modify team member data.
     * @principle Restricts access to sensitive internal data to authorized admin personnel.
     */
    match /team_members/{teamMemberId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.id == teamMemberId;
      allow update: if isAdmin() && resource != null && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Stores client information. Managed by admins. Clients can read their own profile.
     * @path /clients/{clientId}
     * @allow (get) A client reading their own document (`/clients/client_abc`).
     * @allow (create, update, delete) An admin managing client records.
     * @deny (list) A non-admin attempting to list all clients.
     * @deny (update) A client trying to modify their own record.
     * @principle Enforces a combination of ownership for reads and role-based access for writes.
     */
    match /clients/{clientId} {
      allow get: if isAdmin() || isOwner(clientId);
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.id == clientId;
      allow update: if isAdmin() && resource != null && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages core project data. Access is granted to admins and the assigned client.
     * Contains a denormalized `clientId` field for authorization.
     * @path /projects/{projectId}
     * @allow (get) The client whose `uid` matches the project's `clientId` field.
     * @allow (create, update, delete) An admin managing a project.
     * @deny (list) A client attempting to see all projects on the platform.
     * @deny (create) A client attempting to create their own project.
     * @principle Denormalization for Authorization. The `clientId` field allows rules to grant
     * client-specific access without needing slow or impossible cross-collection queries.
     */
    match /projects/{projectId} {
      allow get: if canAccessProjectData(projectId);
      allow list: if isAdmin();
      allow create: if isAdmin() && request.resource.data.id == projectId;
      allow update: if isAdmin() && resource != null && request.resource.data.id == resource.data.id && request.resource.data.clientId == resource.data.clientId;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Project timeline entries. Inherits access rights from the parent project.
     * @path /projects/{projectId}/timeline/{timelineId}
     * @allow (get, list, create) The assigned client or an admin adding a timeline event.
     * @deny (get, list, create) A user who is not the assigned client for this project.
     * @principle Secures subcollection data based on a denormalized field in the parent document.
     */
    match /projects/{projectId}/timeline/{timelineId} {
      allow get: if canAccessProjectData(projectId);
      allow list: if canAccessProjectData(projectId);
      allow create: if canAccessProjectData(projectId) && request.resource.data.projectId == projectId;
      allow update: if canAccessProjectData(projectId) && resource != null && request.resource.data.projectId == resource.data.projectId;
      allow delete: if canAccessProjectData(projectId) && resource != null;
    }

    /**
     * @description Project invoices. Inherits access rights from the parent project.
     * @path /projects/{projectId}/invoices/{invoiceId}
     * @allow (get, list, create) The assigned client or an admin managing invoices.
     * @deny (get, list, create) A user who is not the assigned client for this project.
     * @principle Secures subcollection data based on a denormalized field in the parent document.
     */
    match /projects/{projectId}/invoices/{invoiceId} {
      allow get: if canAccessProjectData(projectId);
      allow list: if canAccessProjectData(projectId);
      allow create: if canAccessProjectData(projectId) && request.resource.data.projectId == projectId;
      allow update: if canAccessProjectData(projectId) && resource != null && request.resource.data.projectId == resource.data.projectId;
      allow delete: if canAccessProjectData(projectId) && resource != null;
    }

    /**
     * @description Messages for a project. Accessible by the client and admins. Senders must be authenticated.
     * @path /projects/{projectId}/messages/{messageId}
     * @allow (create) The assigned client sending a message in their own project channel.
     * @deny (create) A user trying to send a message on behalf of someone else (senderId mismatch).
     * @principle Enforces relational integrity by ensuring the created message correctly links to the
     * project path and reflects the currently authenticated sender.
     */
    match /projects/{projectId}/messages/{messageId} {
      allow get: if canAccessProjectData(projectId);
      allow list: if canAccessProjectData(projectId);
      allow create: if canAccessProjectData(projectId) && request.resource.data.projectId == projectId && request.resource.data.senderId == request.auth.uid;
      allow update: if (isAdmin() || isOwner(resource.data.senderId)) && resource != null && request.resource.data.projectId == resource.data.projectId && request.resource.data.senderId == resource.data.senderId;
      allow delete: if (isAdmin() || isOwner(resource.data.senderId)) && resource != null;
    }
  }
}

    